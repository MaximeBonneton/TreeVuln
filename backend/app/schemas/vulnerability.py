from typing import Any

from pydantic import BaseModel, Field


class VulnerabilityInput(BaseModel):
    """
    Schéma d'entrée pour une vulnérabilité à évaluer.

    Les champs sont flexibles car ils dépendent de la source (Nessus, Trivy, Qualys, etc.)
    et de la configuration de l'arbre par l'utilisateur.
    """

    # Identifiant unique de la vulnérabilité dans le batch
    id: str | None = Field(
        default=None,
        description="Identifiant unique pour tracer la vuln dans les résultats",
    )

    # Champs standards courants (tous optionnels car paramétrables)
    cve_id: str | None = Field(default=None, description="CVE-ID (ex: CVE-2023-12345)")
    cvss_score: float | None = Field(default=None, ge=0, le=10, description="Score CVSS (0-10)")
    cvss_vector: str | None = Field(default=None, description="Vecteur CVSS")
    epss_score: float | None = Field(default=None, ge=0, le=1, description="Score EPSS (0-1)")
    epss_percentile: float | None = Field(default=None, ge=0, le=1)
    kev: bool | None = Field(default=None, description="Présent dans le KEV CISA")

    # Informations sur l'asset
    asset_id: str | None = Field(
        default=None,
        description="ID de l'asset pour lookup dans le référentiel",
    )
    hostname: str | None = None
    ip_address: str | None = None

    # Champs additionnels libres (permet n'importe quel champ custom)
    extra: dict[str, Any] = Field(
        default_factory=dict,
        description="Champs additionnels non-standards",
    )

    def get_field(self, field_name: str) -> Any:
        """
        Récupère la valeur d'un champ, en cherchant d'abord dans les champs
        standards puis dans extra.
        """
        if hasattr(self, field_name) and field_name != "extra":
            value = getattr(self, field_name)
            if value is not None:
                return value
        return self.extra.get(field_name)

    model_config = {"extra": "allow"}
